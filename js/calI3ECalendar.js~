Components.utils.import("resource://calendar/modules/calProviderUtils.jsm");
Components.utils.import("resource://calendar/modules/calUtils.jsm");

function cal3EClient(aUri,aUser,aPass) {
  this.mUser = aUser;
  this.mPass = aPass;
  this.mUri = aUri;
}

cal3EClient.prototype = {
  mUser: null,
  mPass: null,
  mUri: null,

  tReq: null,
  tOK: null,
  tError: null,
  /* prepareXML
   * aName - method name
   * aParams - list of parameters
   * return - generated XML string
   */
  prepareXML: function eee_prepareXML(aName,aParams) {
    aObject = "<methodCall><methodName>ESClient." + aName.toString() + "</methodName><params>";

    for (var paramIndex in aParams) {
      var param = aParams[paramIndex];
      aObject += "<param><value>" + param.toString() + "</value></param>";
    }
    aObject += "</params></methodCall>";
    return aObject;
  },

  /* rpcCall
   * aName - called method name
   * aParams - called method params array
   * aOK - function called when no error aOK(XML response object)
   * aError - function called when error occcured:
   *          1-21 = EEE server errors
   *          0 - Connection error
   *          1xx-5xx = http error
   */
  rpcCall: function eee_rpcCall(aName, aParams, aOK, aError) {
    var aObject = this.prepareXML(aName,aParams);
    var ioService = Components.classes["@mozilla.org/network/io-service;1"].
                    getService(Components.interfaces.nsIIOService);
    
    aUri = ioService.newURI(this.mUri, null, null);
    this.tReq = aObject; 
    this.tOK = aOK;
    this.tError = aError;
    let httpchannel = cal.prepHttpChannel(aUri,aObject,"text/xml",null);
    httpchannel.requestMethod="POST";
   
    cal.sendHttpRequest(cal.createStreamLoader(), httpchannel, this);
    },

    /* onStreamComplete - called when http transaction is completed
     */
    onStreamComplete: function eee_onComplete(aLoader, aContext, aStatus, aResultLength,
                                   aResult) {
      var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
                            getService(Components.interfaces.nsIConsoleService);
      // First test aStatus != 0 means connection error
      if(aStatus != 0) {
        this.tError(0,"Could not connect to server.");
        return;
      }
      let request = aLoader.request.QueryInterface(Components.interfaces.nsIHttpChannel);

      // Second test http response 
      if(request.responseStatus != 200) {
        this.tError(request.responseStatus,request.responseStatusText);
        return;
      }

      let str = cal.convertByteArray(aResult, aResultLength);
      let responseXML = cal.safeNewXML(str);
      var fault = 0;

      // Check error state
      try {
        fault = responseXML.fault.value.struct.member[0].value.int;
      } catch (e) {
      }
      if(fault == 1) {
        // call ESClient.authenticate and send request again
        var aListener = {};
        var pthis = this;
        aListener.onStreamComplete = function onStreamComplete(aLoader, aContext, aStatus, aResultLength,
    	     					 aResult) {
          
           var ioService = Components.classes["@mozilla.org/network/io-service;1"].
                  getService(Components.interfaces.nsIIOService);
           // First test aStatus != 0 means connection error
           if(aStatus != 0) {
             pthis.tError(0,"Could not connect to server.");
             return;
           }
           let request = aLoader.request.QueryInterface(Components.interfaces.nsIHttpChannel);

           // Second test http response 
           if(request.responseStatus != 200) {
             pthis.tError(request.responseStatus,request.responseStatusText);
             return;
           }

           let str = cal.convertByteArray(aResult, aResultLength);
           let responseXML = cal.safeNewXML(str);
           var fault = 0;
           try {
             fault = responseXML.fault.value.struct.member[0].value.int;
           } catch (e) {
           }
           if(fault > 0) {
             pthis.tError(fault,responseXML.fault.value.struct.member[1].value);
             return;
           }

           aUri = ioService.newURI(pthis.mUri, null, null);
           let httpchannel = cal.prepHttpChannel(aUri,pthis.tReq,"text/xml",null);
           httpchannel.requestMethod="POST";
           let str = cal.convertByteArray(aResult, aResultLength);
   
           cal.sendHttpRequest(cal.createStreamLoader(), httpchannel, pthis);
            
        };
        var params = Array();
        params[0] = this.mUser;
        params[1] = this.mPass;
        var aObject = this.prepareXML("authenticate",params); 
        var ioService = Components.classes["@mozilla.org/network/io-service;1"].
                        getService(Components.interfaces.nsIIOService);
          
        aUri = ioService.newURI(this.mUri, null, null);
        let httpchannel = cal.prepHttpChannel(aUri,aObject,"text/xml",null);
        httpchannel.requestMethod="POST";
        aConsoleService.logStringMessage("test() - " + aObject);
   
        cal.sendHttpRequest(cal.createStreamLoader(), httpchannel, aListener);
        return;
      }
      if(fault > 0) {
        pthis.tError(fault,responseXML.fault.value.struct.member[1].value);
        return;
      }
      this.tOK(responseXML);  
    }
};

// 
// calI3EProvider() - construct the method
//
function cal3ECalendar() {
  this.initProviderBase();
}

cal3ECalendar.prototype = {
    __proto__: cal.ProviderBase.prototype,
    // nsISupport interface
    QueryInterface: function eee_QueryInterface(aIID) {
        return doQueryInterface(this, cal3ECalendar.prototype, aIID,
                                [Components.interfaces.calICalendarProvider,
                                Components.interfaces.calICalendar]);
    },
    // calICalendar
    get type caldav_get_type() { return "3e"; },
    
    mDisabled: true,

    get name eee_getName() {
        return this.mTitle;
    },
    set name eee_setName(v) {
        this.mTitle = v;
    },

    get access eee_getAccess() {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },
    set access eee_setAccess(v) {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },

    get selected eee_getSelected() {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },
    set selected eee_setSelected(v) {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },

    get hidden eee_getHidden() {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },
    set hidden eee_setHidden(v) {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },
    get color eee_getColor() {
        return this.mColor;
    },
    set color cGC_setColor(v) {
        this.mColor = v;
    },

    get timezone cGC_getTimezone() {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },
    set title cGC_setTitle(v) {
        throw Components.results.NS_ERROR_NOT_IMPLEMENTED;
    },
    mCalendarUserAddress: null,
    get calendarUserAddress eee_get_calendarUserAddress() {
        return this.mCalendarUserAddress;
    },

    mPrincipalUrl: null,
    get principalUrl eee_get_principalUrl() {
        return this.mPrincipalUrl;
    },

    get canRefresh eee_get_canRefresh() {
        return true;
    },

    // defined uri provided by user
    mUri: null,
    mServerUri: null,
    mServerUser: null,
    mServerPass: null,
    mServerCalendar: null,
    mLocalCache: null,
    initLocalCache: function initLocalCache() {
        this.mLocalCache = {};
    }
    get uri eee_get_uri() { return this.mUri },

    set uri eee_set_uri(aUri) {
        this.mUri = aUri;
        var tUri = Components.classes["@mozilla.org/network/standard-url;1"].
                    getService(Components.interfaces.nsIURI);
        tUri.spec = aUri.spec;

        if(aUri != null) {
  
          this.mServerUser = tUri.username + "@" + tUri.host;
          this.mServerPass = tUri.password;
          this.mServerUri = "https://" + tUri.host + ":" + (tUri.port == -1 ? "4444" : tUri.port) + "/";
          this.mServerCalendar = tUri.path.substring(1);
        }
        this.mTitle = this.mServerCalendar;
        return aUri;
    },

    get transientProperties eee_get_transientProperties() {
        return true;
    },
    mTitle: null,
    mColor: null,
    setProperty: function eee_setProperty(aName,aValue) {
        var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
        getService(Components.interfaces.nsIConsoleService);

        aConsoleService.logStringMessage("setProperty() - " +this.mUri.spec +", " + aName + " = " + aValue);
        switch (aName) {
            case "name": 
                this.mTitle = aValue;
                return;
            case "color":
                this.mColor = aValue;
                return;
        }
    },
    getProperty: function eee_getProperty(aName) {
        switch (aName) {
            case "organizerId":
                //if (this.calendarUserAddress) {
                //    return this.calendarUserAddress;
                //} // else use configured email identity
                break;
            case "capabilities.tasks.supported":
	    case "capabilities.timezones.floating.supported":
                return false;
	    case "capabilities.attachments.supported":
	    case "capabilities.privacy.supported":
	    case "itip.transport":
                return false;
            case "requiresNetwork":
            case "capabilities.events.supported":
	    case "capabilities.timezones.UTC.supported":
                return true;
            case "name":
                return this.mTitle;
            case "color":
                return this.mColor;
        }
        return this.__proto__.__proto__.getProperty.apply(this, arguments);
    },
    prepareSerializedItem: function eee_prepareSerialiedItem(aItem) {
        // Serialize item 
        var serialized = cal.getSerializedItem(aItem);
        var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
        getService(Components.interfaces.nsIConsoleService);

        aConsoleService.logStringMessage("prepareSerializedItem() - " +serialized);
        // convert dtstart and dtend to UTC
        var timezoneUTC = aItem.startDate.timezone.provider.UTC;
        var startDate = aItem.startDate.getInTimezone(timezoneUTC);
        var text = startDate.toString();
        var dtstart="DTSTART:"+text.substr(0,4)+text.substr(5,2)+text.substr(8,2)+"T"+text.substr(11,2)+text.substr(14,2)+text.substr(17,2)+"Z";
        var endDate = aItem.endDate.getInTimezone(timezoneUTC);
        var text = endDate.toString();
        var dtend="DTEND:"+text.substr(0,4)+text.substr(5,2)+text.substr(8,2)+"T"+text.substr(11,2)+text.substr(14,2)+text.substr(17,2)+"Z";

        // clean parts rejected by server
        var split = serialized.search("BEGIN:VEVENT");
        var xevent = serialized.substring(split);
        xevent = xevent.replace(/DTSTART;TZID.*/,dtstart);
        xevent = xevent.replace(/DTEND;TZID.*/,dtend);
        var ret = xevent.replace(/END:VCALENDAR/,"");
        return ret;
    },
    /**
     * addItem()
     * we actually use doAdoptItem()
     *
     * @param aItem       item to add
     * @param aListener   listener for method completion
     */
    addItem: function eee_addItem(aItem, aListener) {
        var newItem = aItem.clone();
        return this.doAdoptItem(newItem, aListener, false);
    },

    /**
     * adoptItem()
     * we actually use doAdoptItem()
     *
     * @param aItem       item to check
     * @param aListener   listener for method completion
     */
    adoptItem: function eee_adoptItem(aItem, aListener) {
        return this.doAdoptItem(aItem, aListener, false);
    },

    /**
     * Performs the actual addition of the item to CalDAV store
     *
     * @param aItem       item to add
     * @param aListener   listener for method completion
     * @param aIgnoreEtag ignore item etag
     */
    doAdoptItem: function eee_doAdoptItem(aItem, aListener, aIgnoreEtag) {
        if (aItem.id == null && aItem.isMutable) {
            aItem.id = getUUID();
        }

        if (aItem.id == null) {
            this.notifyOperationComplete(aListener,
                                         Components.results.NS_ERROR_FAILURE,
                                         Components.interfaces.calIOperationListener.ADD,
                                         aItem.id,
                                         "Can't set ID on non-mutable item to addItem");
            return;
        }

        var rpc = new cal3EClient(this.mServerUri,this.mServerUser,this.mServerPass);
        var pthis = this;
        var aok = function adopt_aok(xml) {
            pthis.notifyOperationComplete(aListener,
                                         Components.results.NS_OK,
                                         Components.interfaces.calIOperationListener.ADD,
                                         aItem.id,
                                         aItem);
            pthis.observers.notify("onAddItem",[aItem]);
            return;
        };
        var aerror = function adopt_aerror(eno,text) {
            pthis.notifyOperationComplete(aListener,
                                         Components.results.NS_ERROR_FAILURE,
                                         Components.interfaces.calIOperationListener.ADD,
                                         aItem.id,
                                         "Server returned error status: " + text);
            return;
        };
      
        var params = Array();
        params[0] = this.mServerCalendar;
        params[1] = this.prepareSerializedItem(aItem);
        rpc.rpcCall("addObject",params,aok,aerror);
    },

    /**
     * modifyItem(); required by calICalendar.idl
     * we actually use doModifyItem()
     *
     * @param aItem       item to check
     * @param aListener   listener for method completion
     */
    modifyItem: function eee_modifyItem(aNewItem, aOldItem, aListener) {
        if (aNewItem.id == null) {
            this.notifyOperationComplete(aListener,
                                         Components.results.NS_ERROR_FAILURE,
                                         Components.interfaces.calIOperationListener.MODIFY,
                                         aNewItem.id,
                                         "ID for modifyItem doesn't exist or is null");
            return;
        }
        var rpc = new cal3EClient(this.mServerUri,this.mServerUser,this.mServerPass);
        var pthis = this;
        var aok = function adopt_aok(xml) {
             pthis.notifyOperationComplete(aListener,
                                         Components.results.NS_OK,
                                         Components.interfaces.calIOperationListener.MODIFY,
                                         aNewItem.id,
                                         aNewItem);
             pthis.observers.notify("onModifyItem",[aNewItem, aOldItem]);
            return;
        };
        var aerror = function adopt_aerror(eno,text) {
            pthis.notifyOperationComplete(aListener,
                                         Components.results.NS_ERROR_FAILURE,
                                         Components.interfaces.calIOperationListener.MODIFY,
                                         aNewItem.id,
                                         "Server returned error status: " + text );
            return;
        };
      
        var params = Array();
        params[0] = this.mServerCalendar;
        params[1] = this.prepareSerializedItem(aNewItem);
        rpc.rpcCall("updateObject",params,aok,aerror);
    },

    /**
     * deleteItem(); required by calICalendar.idl
     *
     * @param aItem       item to delete
     * @param aListener   listener for method completion
     */
    deleteItem: function eee_deleteItem(aItem, aListener) {
        if (aItem.id == null) {
            this.notifyOperationComplete(aListener,
                                         Components.results.NS_ERROR_FAILURE,
                                         Components.interfaces.calIOperationListener.DELETE,
                                         aItem.id,
                                         "ID doesn't exist for deleteItem");
            return;
        }

        var rpc = new cal3EClient(this.mServerUri,this.mServerUser,this.mServerPass);
        var pthis = this;
        var aok = function adopt_aok(xml) {
              pthis.notifyOperationComplete(aListener,
                                         Components.results.NS_OK,
                                         Components.interfaces.calIOperationListener.DELETE,
                                         aItem.id,
                                         aItem);
              pthis.observers.notify("onDeleteItem",[aItem]);
            return;
        };
        var aerror = function adopt_aerror(eno,text) {
            pthis.notifyOperationComplete(aListener,
                                         Components.results.NS_ERROR_FAILURE,
                                         Components.interfaces.calIOperationListener.DELETE,
                                         aItem.id,
                                         "Server returned error status" + text);
            return;
        };

        var params = Array();
        params[0] = this.mServerCalendar;
        params[1] = aItem.id;
        rpc.rpcCall("deleteObject",params,aok,aerror);
    },

    // void getItem( in string id, in calIOperationListener aListener );
    getItem: function eee_getItem(aId, aListener) {
        // Get all calendar and find correct item - better solution would be add "uid(string)" to filter
        // Hopefully this was never seen called so this is not big problem
        var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
        getService(Components.interfaces.nsIConsoleService);

        aConsoleService.logStringMessage("getItem()" + aId);
      if (!aListener)
            return;

      const calICalendar = Components.interfaces.calICalendar;
      const calIRecurrenceInfo = Components.interfaces.calIRecurrenceInfo;
      var rpc = new cal3EClient(this.mServerUri,this.mServerUser,this.mServerPass);
      // + DEBUG
      var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
                            getService(Components.interfaces.nsIConsoleService);

      var acalendar = this;
      var pthis = this;
      var aok = function aok(aXML) {
           let value = aXML.params.param.value[0];
           var parser = Components.classes["@mozilla.org/calendar/ics-parser;1"]
                        .createInstance(Components.interfaces.calIIcsParser);
           parser.parseString(value, null);
           var mItems = parser.getItems({});

           var itemsFound = Array();
           for (var itemIndex in mItems) {
             var item = mItems[itemIndex];
             var isEvent_ = isEvent(item);
             item.calendar = acalendar;
             if (item.id == aId) {
                itemsFound.push(item);
                break;
             }
           }
           aListener.onGetResult (acalendar,
                                  Components.results.NS_OK,
                                  Components.interfaces.calIEvent,
                                  null,
                                  itemsFound.length,
                                  itemsFound);

           acalendar.notifyOperationComplete(aListener,
                                  Components.results.NS_OK,
                                  Components.interfaces.calIOperationListener.GET,
                                  null,
                                  null);
      };
      var filter = "NOT deleted()";

      var params = Array();
      params[0] = this.mServerCalendar
      params[1] = filter;
      rpc.rpcCall("queryObjects",params,aok,null);
      return;

    },


    // void getItems( in unsigned long aItemFilter, in unsigned long aCount,
    //                in calIDateTime aRangeStart, in calIDateTime aRangeEnd,
    //                in calIOperationListener aListener );
    // * gets data from localy cached calendar
    getItems: function eee_getItems(aItemFilter, aCount, aRangeStart,
                                       aRangeEnd, aListener) {
      if (!aListener)
            return;

      const calICalendar = Components.interfaces.calICalendar;
      const calIRecurrenceInfo = Components.interfaces.calIRecurrenceInfo;

      var wantUnrespondedInvitations = ((aItemFilter & calICalendar.ITEM_FILTER_REQUEST_NEEDS_ACTION) != 0);
      wantUnrespondedInvitations = false;
      var superCal;
      function checkUnrespondedInvitation(item) {
          var att = superCal.getInvitedAttendee(item);
          return (att && (att.participationStatus == "NEEDS-ACTION"));
      }
      var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
                            getService(Components.interfaces.nsIConsoleService);
        aConsoleService.logStringMessage("getItems() " + aItemFilter);
      
      var wantEvents = ((aItemFilter & calICalendar.ITEM_FILTER_TYPE_EVENT) != 0);
      if(!wantEvents) {
          // bail.
          this.notifyOperationComplete(aListener,
                                       Components.results.NS_ERROR_FAILURE,
                                       Components.interfaces.calIOperationListener.GET,
                                       null,
                                       "Bad aItemFilter passed to getItems");
          return;
      }

      var itemCompletedFilter = ((aItemFilter & calICalendar.ITEM_FILTER_COMPLETED_YES) != 0);
      var itemNotCompletedFilter = ((aItemFilter & calICalendar.ITEM_FILTER_COMPLETED_NO) != 0);
      function checkCompleted(item) {
          return (item.isCompleted ? itemCompletedFilter : itemNotCompletedFilter);
      }

      // return occurrences?
      var itemReturnOccurrences = ((aItemFilter & calICalendar.ITEM_FILTER_CLASS_OCCURRENCES) != 0);

      // figure out the return interface type
      var typeIID = null;
      if (itemReturnOccurrences) {
          typeIID = Components.interfaces.calIItemBase;
      } else {
          typeIID = Components.interfaces.calIEvent;
      }

      aRangeStart = ensureDateTime(aRangeStart);
      aRangeEnd = ensureDateTime(aRangeEnd);

      // request

      var acalendar = this;
      var pthis = this;

      var itemsFound = Array();
      for (var itemIndex in mLocalCache) {
        var item = mLocalCache[itemIndex];
        var isEvent_ = isEvent(item);
        item.calendar = acalendar;
        if (itemReturnOccurrences && item.recurrenceInfo) {
          var occurrences = item.recurrenceInfo.getOccurrences(
              aRangeStart, aRangeEnd, aCount ? aCount - itemsFound.length : 0, {});
          if (wantUnrespondedInvitations) {
            occurrences = occurrences.filter(checkUnrespondedInvitation);
          }
          if (!isEvent_) {
            occurrences = occurrences.filter(checkCompleted);
          }
          itemsFound = itemsFound.concat(occurrences);
        } else if ((!wantUnrespondedInvitations || checkUnrespondedInvitation(item)) &&
                  (isEvent_ || checkCompleted(item)) &&
                  checkIfInRange(item, aRangeStart, aRangeEnd)) {
                // This needs fixing for recurring items, e.g. DTSTART of parent may occur before aRangeStart.
                // This will be changed with bug 416975.
                itemsFound.push(item);
        }
        if (aCount && itemsFound.length >= aCount) {
          break;
        }
      }
      aListener.onGetResult (acalendar,
                             Components.results.NS_OK,
                             Components.interfaces.calIEvent,
                             null,
                             itemsFound.length,
                             itemsFound);

      acalendar.notifyOperationComplete(aListener,
                             Components.results.NS_OK,
                             Components.interfaces.calIOperationListener.GET,
                             null,
                             null);
      
 /*
      var timezoneUTC = aRangeStart.timezone.provider.UTC;
      var bRangeStart = aRangeStart.getInTimezone(timezoneUTC);
      var bRangeEnd = aRangeEnd.getInTimezone(timezoneUTC);

      var filter = "date_from('"+bRangeStart.toString().replace(/\//g,"-").substring(0,19);
 //     filter = filter + "') AND date_to('"+bRangeEnd.toString().replace(/\//g,"-").substring(0,19);
      filter = filter + "') AND NOT deleted()";

      var params = Array();
      params[0] = this.mServerCalendar
      params[1] = filter;
      rpc.rpcCall("queryObjects",params,aok,null);
      return;*/
    },
    /* 
     * refresh - fills local cache from server
     */
    refresh: function eee_refresh() {
      var aConsoleService = Components.classes["@mozilla.org/consoleservice;1"].
      getService(Components.interfaces.nsIConsoleService);

      aConsoleService.logStringMessage("refresh()");
      //this.observers.notify("onLoad",[this]);
      // request
      var rpc = new cal3EClient(this.mServerUri,this.mServerUser,this.mServerPass);
      var acalendar = this;
      var pthis = this;
      var aok = function aok(aXML) {
           let value = aXML.params.param.value[0];
           var parser = Components.classes["@mozilla.org/calendar/ics-parser;1"]
                        .createInstance(Components.interfaces.calIIcsParser);
           parser.parseString(value, null);
           var mItems = parser.getItems({});

           var mLocalCache = {};
           for (var itemIndex in mItems) {
             var item = mItems[itemIndex];
             item.calendar = acalendar;
             mLocalCache[item.id] = item;
             }
           }
      };
 
      var filter = "NOT deleted()";

      var params = Array();
      params[0] = this.mServerCalendar
      params[1] = filter;
      rpc.rpcCall("queryObjects",params,aok,null);
      return;

    }
};


function cal3EObserver(aCalendar) {
    this.mCalendar = aCalendar;
}

cal3EObserver.prototype = {
    mCalendar: null,
    mInBatch: false,

    // calIObserver:
    onStartBatch: function() {
        this.mCalendar.observers.notify("onStartBatch");
        this.mInBatch = true;
    },
    onEndBatch: function() {
        this.mCalendar.observers.notify("onEndBatch");
        this.mInBatch = false;
    },
    onLoad: function(calendar) {
        this.mCalendar.observers.notify("onLoad", [calendar]);
    },
    onAddItem: function(aItem) {
        this.mCalendar.observers.notify("onAddItem", [aItem]);
    },
    onModifyItem: function(aNewItem, aOldItem) {
        this.mCalendar.observers.notify("onModifyItem", [aNewItem, aOldItem]);
    },
    onDeleteItem: function(aDeletedItem) {
        this.mCalendar.observers.notify("onDeleteItem", [aDeletedItem]);
    },
    onPropertyChanged: function(aCalendar, aName, aValue, aOldValue) {
        this.mCalendar.observers.notify("onPropertyChanged", [aCalendar, aName, aValue, aOldValue]);
    },
    onPropertyDeleting: function(aCalendar, aName) {
        this.mCalendar.observers.notify("onPropertyDeleting", [aCalendar, aName]);
    },

    onError: function(aCalendar, aErrNo, aMessage) {
        this.mCalendar.readOnly = true;
        this.mCalendar.notifyError(aErrNo, aMessage);
    }
};
